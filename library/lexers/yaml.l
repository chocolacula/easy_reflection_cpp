// A fast YAML 1.2 parser and writer
// Written by Robert van Engelen
// Edited by Maxim Voloshin
//
// https://yaml.org/spec/1.2/spec.html
//
// YAML doesn't define a formal grammar but instead defines over 200 rules.
// YAML uses indent to define structure.  This RE/flex lexer and parser uses
// indentation anchors \i, \j, and \k to parse YAML structures.
//
// This YAML parser follows the specification but does not generate errors for
// invalid YAML syntax, just tries to make sense of it all (YAML is complex!).
//
// Note:
// - directives are ignored
// - anchors (&id and *id) are stored with the YAML structure, but not resolved
// - tags (!tag) are parsed and stored with the YAML structure, but not written
// - scalars are always stored as strings (not converted to numbers/Booleans)
//
// YAML tokens generated by the lexer:
// - 'S' YAML document start marker ---
// - 'E' YAML document end marker ...
// - ';' newline, i.e. \r?\n
// - '=' one or more empty or blank lines
// - '$' string (a YAML scalar, quoted scalar, or block scalar)
// - '-' sequence dash
// - '?' map key
// - ':' map colon
// - '>' indent after ';' or '='
// - '<' dedent after ';' or '='
// - '[' flow sequence open bracket
// - ']' flow sequence close bracket
// - '{' flow sequence open brace
// - '}' flow sequence close brace
// - ',' flow sequence or map comma
//
// YAML test files:
// - https://www.genivia.com/files/yamltests.zip

%option lexer=LexerYaml
%option namespace=rf_yaml

%o fast freespace dotall unicode noline

%top{
  #include <cstdlib> // strtoul()
  #include <iostream> // std::cout etc.
  #include <iomanip>  // std::setw
  #include <vector>   // to store YAML containers

  #include "er/serialization/parsing/position.h"
}

%class{
 public:
  LexerYaml(const char* input, size_t input_size) : LexerYaml(reflex::Input(input, input_size)){
  }

  rr::Position get_position() {
    return rr::Position{.column = columno(), .line_number = lineno()};
  }

  inline std::string& get_word() {
    return _word;
  }

  // count number of newlines matched
  size_t newlines()
  {
    return chr() == '\r' ? size()/2 : size();
  }

  // parse the indent value given after a '|' or '>', if present
  void parse_indent(size_t offset)
  {
    indent = strtoul(text() + offset, NULL, 10);
  }

  // use the parsed indent value given after a '|' or '>' to adjust the indent
  void adjust_indent()
  {
    if (indent > 0)
    {
      std::vector<size_t>& stops = matcher().stops();
      size_t spaces = stops.back();
      if (spaces > indent)
      {
        stops.pop_back();
        if (stops.empty())
        {
          stops.push_back(indent);
        }
        else
        {
          spaces -= stops.back();
          stops.push_back(stops.back() + indent);
        }
        _word.append(spaces - indent, ' ');
      }
    }
  }

  // clear the string scalar before accumulating a new scalar
  void clear() {
    _word.clear();
  }

  // add one or n chars c to the string
  void add(wchar_t c, size_t n = 1) {
    while (n-- > 0) {
      _word.push_back(c);
    }
  }

  // add indent to the string, prefixed with a \n if nl is true
  void add_indent() {
    if (nl) {
      _word.push_back('\n');
    }
    size_t stop = matcher().last_stop();
    if (size() > stop) {
      _word.append(size() - stop, ' ');
    }
  }

  // if nl is true, add a \n to the string then reset nl
  void add_newline() {
    if (nl) {
      _word.push_back('\n');
      nl = false;
    }
  }

  // add sp spaces to the string
  void add_space() {
    _word.append(sp, ' ');
    sp = 0;
  }

  // chomp the string
  void chomp()
  {
    switch (mode)
    {
      case CLIP:
        while (!_word.empty() && _word.back() == '\n') {
          _word.pop_back();
        }
        _word.push_back('\n');
        break;
      case STRIP:
        while (!_word.empty() && _word.back() == '\n') {
          _word.pop_back();
        }
        break;
      case KEEP:
        break;
    }
  }

  unsigned long indent;            // block scalar indent value
  size_t sp;                       // insert spaces in folded block scalar
  bool nl;                         // insert newline in folded block scalar
  enum { CLIP, STRIP, KEEP } mode; // chomp mode

 private:
  std::string _word; // string to accumulate YAML scalars
}

// Lexer class initialization at construction
%init {
  indent = 0;
  nl = false;
  sp = 0;
  mode = CLIP;
}

%x APOS QUOT PRES FOLD PBLK FBLK

direct  \h* % [^\n]* \n
comment \h* # [^\n]*
ic      [^-?:\\\[\]{},!&*#'"@`[:space:]]
rc      [^\\\[\]{}:,[:space:]]
rd      [^-\\\[\]{}:,[:space:]]
rh      [^#\\\[\]{}:,[:space:]]
scalar  ({ic} | [-:?] {rd} | --- {rc}) ({rc} | :+ {rc} | \h+ {rh})*
tag     [!&*] {rc}+
h2      [[:xdigit:]]{2}
h4      [[:xdigit:]]{4}
h8      [[:xdigit:]]{8}
nl      \h* (# [^\n]* | \r)? \n
lf      \r? \n
bl      {lf} (\h* {lf})+
br      \h+ | (\h* {lf})+

%%

{direct}        { /* ignore directive */ }
{comment}       { /* ignore comment */ }
\h* {lf}        { return ';'; }
\h* {bl}        { return '='; }
^ \h+ \i        { return '>'; }
^ \h+ \j        |
\j              { return '<'; }
\h+             { /* ignore spaces and tabs */ }
"---" {br}      { return 'S'; }
"..." {br}      { return 'E'; }
"-"             { return '-'; }
"?"             { return '?'; }
":"             { return ':'; }
","             { return ','; }
"["             { return '['; }
"]"             { return ']'; }
"{"             { return '{'; }
"}"             { return '}'; }
"'"             { clear(); start(APOS); }
\"              { clear(); start(QUOT); }
"|"  \d* {nl}   { clear(); parse_indent(1); mode = CLIP;  start(PRES); }
"|-" \d* {nl}   { clear(); parse_indent(2); mode = STRIP; start(PRES); }
"|+" \d* {nl}   { clear(); parse_indent(2); mode = KEEP;  start(PRES); }
">"  \d* {nl}   { clear(); parse_indent(1); mode = CLIP;  start(FOLD); }
">-" \d* {nl}   { clear(); parse_indent(2); mode = STRIP; start(FOLD); }
">+" \d* {nl}   { clear(); parse_indent(2); mode = KEEP;  start(FOLD); }
{tag}           { _word = str(); return chr(); }
{scalar}        { _word = str(); return '$'; }

<APOS>{
'               { start(INITIAL); return '$'; }
''              { add('\''); }
}

<QUOT>{
\\ {lf}         { /* ignore \LF */ }
\"              { start(INITIAL); return '$'; }
\\ 0            { add('\0'); }
\\ a            { add('\a'); }
\\ b            { add('\b'); }
\\ t            { add('\t'); }
\\ n            { add('\n'); }
\\ v            { add('\v'); }
\\ f            { add('\f'); }
\\ r            { add('\r'); }
\\ e            { add(0x1b); }
\\ N            { add(0x85); }
\\ _            { add(0xa0); }
\\ L            { add(0x2028); }
\\ P            { add(0x2029); }
\\ x {h2}       { add(strtoul(text() + 2, NULL, 16)); }
\\ u {h4}       { add(strtoul(text() + 2, NULL, 16)); }
\\ U {h8}       { add(strtoul(text() + 2, NULL, 16)); }
\\ .            { add(str()[1]); }
}

<APOS,QUOT>{
^ \h+ \k?       { /* ignore nodent/undent */ }
\h* {lf}        { add(' '); }
{bl}            { add('\n', newlines() - 1); }
.               { add(wchr()); }
}

<PRES>{
^ \h+ \i        { adjust_indent(); start(PBLK); }
}

<FOLD>{
^ \h+ \i        { adjust_indent(); sp = 0; nl = false; start(FBLK); }
}

<PBLK>{
{lf}            { add('\n'); }
{bl}            { add('\n', newlines()); }
^ \h* \j        |
\j              { chomp(); start(INITIAL); return '$'; }
^ \h+           { }
^ \h+ \k        { add_indent(); }
.               { add(chr()); }
}

<FBLK>{
\h+ {lf}        { sp = size() - 1 - (*(matcher().end() - 2) == '\r'); }
{lf}            { sp = 1; }
{bl}            { add('\n', newlines() - 1); }
^ \h* \j        |
\j              { chomp(); start(INITIAL); return '$'; }
^ \h+           { add_newline(); }
^ \h+ \k        { sp = 0; nl = true; add_indent(); }
.               { add_space(); add(chr()); }
}

%%
